# This file defines the CI/CD pipeline for GitLab
variables:
  GIT_STRATEGY: fetch
  # BASE IMAGE (kind of the folder for all images)
  BASE_IMAGE: registry.gitlab.com/mathis1993/mood_diary_project

  # APPLICATION IMAGES
  APP_IMAGE: $BASE_IMAGE:django.$CI_COMMIT_REF_SLUG
  APP_TEST_IMAGE: $APP_IMAGE.test

stages:
  - build
  - test
  # - release
  - deploy

build_mood_diary:
  stage: build
  # The runner defines a tag and will only pick up jobs with this tag
  tags:
    - shell  # runner with shell executor
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY
  script:
    - docker build --tag $APP_TEST_IMAGE --target=staging .
    - docker push $APP_TEST_IMAGE

test_mood_diary:
  stage: test
  image: $APP_TEST_IMAGE
  tags:
    - docker  # runner with docker executor
  before_script:
    - cd /app
  services:
    - name: postgres:15.2
      command: [ "postgres", "-c", "fsync=off", "-c", "synchronous_commit=off", "-c", "full_page_writes=off", "-c", "random_page_cost=1.0" ]
      alias: postgres
    - redis
  variables:
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
    POSTGRES_DB: mood_diary_dev
    POSTGRES_HOST: postgres
    POSTGRES_PORT: 5432
    POSTGRES_HOST_AUTH_METHOD: trust
    REDIS_CACHE_URL: redis://redis:6379/1
  script:
    - pytest -n auto --dist loadfile --cov --cov-config=pyproject.toml --cov-report=xml:coverage.xml --record-mode=none
    - sed -i "s=<source>.*</source>=<source>/mood_diary_project</source>=g" coverage.xml
  after_script:
    - cd /app && coverage report
    - mkdir -p /builds/Mathis1993/mood_diary_project/
    - cp /app/coverage.xml /builds/Mathis1993/mood_diary_project/coverage.xml
  coverage: '/TOTAL.+ ([0-9]{1,3}.[0-9]{1,3}%)/'
  artifacts:
    expire_in: 4 weeks
    when: always
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml

release_mood_diary:
  stage: release
  tags:
    - shell
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY
  script:
    - docker build --tag $APP_IMAGE --target=base .
    - docker push $APP_IMAGE
  only:
    - main  # only release when pushing to main branch

deploy_to_staging:
    stage: deploy
    tags:
      - shell
    script:
      - cp infra/staging/docker-compose.yml ${DEPLOY_TARGET_DIR}/docker-compose.yml
      - cd ${DEPLOY_TARGET_DIR}
      - docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY
      - docker compose pull && docker compose up -d
      - docker compose exec django python manage.py migrate
      - docker compose exec django python manage.py shell_plus -c "from mood_diary.seed_database import seed_database_staging; seed_database_staging()"
    variables:
      DEPLOY_TARGET_DIR: /home/docker/mood_diary
    only:
        - develop  # only deploy staging when pushing to develop branch

deploy_to_production:
    stage: deploy
    tags:
      - shell
    script:
      - apt update && apt install openssh-client curl jq -y
      - scp infra/production/docker-compose.yml ${DEPLOY_SSH_USER}@${DEPLOY_SSH_HOST}:${DEPLOY_TARGET_DIR}/docker-compose.yml
      - ssh -l $DEPLOY_SSH_USER $DEPLOY_SSH_HOST "
        cd ${DEPLOY_TARGET_DIR}
        docker login -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN $CI_REGISTRY
        docker compose pull && docker compose up -d
        docker compose exec django python manage.py migrate"
    variables:
      DEPLOY_TARGET_DIR: /home/docker/mood_diary
    only:
        - main  # only deploy when pushing to main branch
